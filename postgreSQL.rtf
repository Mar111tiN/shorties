{\rtf1\ansi\ansicpg1252\cocoartf2580
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Bold;\f1\fswiss\fcharset0 Helvetica;\f2\fnil\fcharset0 Menlo-Regular;
}
{\colortbl;\red255\green255\blue255;\red0\green0\blue0;}
{\*\expandedcolortbl;;\csgray\c0;}
\paperw11905\paperh16837\margl1440\margr1440\vieww16740\viewh15180\viewkind0
\pard\tx566\tx1133\tx1700\tx2267\tx2834\tx3401\tx3968\tx4535\tx5102\tx5669\tx6236\tx6803\tx7395\tx8294\tx8964\tx9762\tx10321\tx11245\tx12132\tx12814\tx13879\tx14653\tx15260\tx15967\pardirnatural\partightenfactor0

\f0\b\fs28 \cf0 Installation:
\f1\b0\fs24 \
\
Mac: \
	via Postgres App\
\
Cloud:\
	ElephantSQL is a cloud provider with a free tier\
\
Linux: CentOS\
	download fitting version of postgreSQL:\
	$ curl -O {\field{\*\fldinst{HYPERLINK "https://download.postgresql.org/pub/repos/yum/10/redhat/rhel-7-x86_64/pgdg-centos10-10-2.noarch.rpm"}}{\fldrslt link }}\
	install the RPM:\
	$ rpm pgdg-centos10-10-2.noarch.rpm\
or:\
	$ 
\f2\fs22 \cf2 \CocoaLigature0 sudo yum install postgresql-server postgresql-contrib
\f1\fs24 \cf0 \CocoaLigature1 \
\
\

\f0\b\fs36 \ul psql CLI
\fs28 \ulnone \

\f1\b0\fs24 \

\f0\b INIT: 
\f1\b0 \
	enter psql CLI:   \
	=> psql -h localhost -p <PORT> -d <DBNAME> -U <USER>		-h localhost is default\
 	=> CREATE USER 'mahtin' WITH PASSWORD '.....'; \
	=> create database 'dbname';\
	=> GRANT ALL PRIVILEGES ON DATABASE 'dbname' to 'mahtin';\
\

\f0\b Command line tools 
\f1\b0 \
the standard superuser of a database is the current bash user\
$ createdb mydb			creates a new database for current user\
$ dropdb mydb				deletes database\
$ psql mydb				access your database ( \
	=# 					connected as superuser\
	=>					connected as normal user\
\

\f0\b psql meta commands\

\f1\b0 => \\command				\\ prepends all psql metacommands\
=> \\h						help\
=> \\dt					list database tables\
=> \\d tablename			shows colums and data types of table\
=> \\q						quits psql\
=> \\\
\
\

\f0\b \

\fs36 \ul SQL
\fs28 \ulnone \
\

\f1\b0\fs24 in psql, you can control the database using SQL commands and psql metacommands:\

\f0\b \
general syntax:
\f1\b0 \
=> SQL COMMAND					line breaks do not matter\
	CONTINUED;					; commits command to db\
=> comMAND;						SQL is case-insensitive\
SQL consists of preset keywords and user-defined identifiers \
any string enclosed in " " is not a keyword but an identifier\
\
string constants are enclosed in ' \'85' and for escape strings you can  use e'    ' to be able to use c-style escape:\
e'\'85..\\t\'85.\\n\'85' \
\
\

\f0\b\fs28 TABLES
\fs24 \
\
create tables
\f1\b0 \
=> CREATE TABLE <table_name> ( 			creates an empty table\
	id INTEGER PRIMARY KEY,\
	<column_name>   <data_type>,		 	with all the columns defined between the brackets\
	<column_name>   <data_type>,\
\
you can directly use datatype SERIAL for primary key for autoincrementation\
\
to check if a table exists:\
=> CREATE TABLE IF NOT EXISTS <table_name> (\'85)\
\
\

\f0\b relationships
\f1\b0 \
with foreign key relationships you can maintain database integrity and link tables\
=> CREATE TABLE <table1> ( 			\
	<column1>   <data_type>	PRIMARY KEY,				column1 is defined as primary key\
	<column2>   <data_type>\
	);\
=> CREATE TABLE <table2> ( 			\
	<column1>   <data_type>	\
	FOREIGN KEY(<column1>) REFERENCES <table1>( <column1>),     column1 is linked to table1\
	<column2>   <data_type>\
	);\
now, you can only enter column1 values in table2 that exist in column1 of table1\
\
delete related cols:\
=> CREATE TABLE <table1> (\'85\'85..\
	FOREIGN KEY(<column1>) REFERENCES <table1>( <column1>) \ul ON DELETE CASCADE\
\
\ulnone if you want to prevent deletion of related items:\
	\'85 ON DELETE RESTRICT\
\

\f0\b\fs28 general CRUD
\fs26 \

\f1\b0\fs24 \
=> INSERT INTO <table_name> 			insert a row with values into the table\
	(<column_name>, <column_name>) 		if columns are omitted, all columns are assumed\
	VALUES (value1, value2) RETURNING id; returning is good if you want to use autogenerated ids for further queries				\
if using SQL commands in a python program, values can be set as ? and passed as additional arguments\
\
	\
=> UPDATE <table_name> 				update allows changing the rows of a table\
	SET <column_name> = value, <column_name> = value\
	WHERE <column_name> = value\
\
=> DELETE from <table_name>  WHERE <column_name> = value RETURNING *;	you can use RETURNING * to receive the rows that where deleted\
\
\

\f0\b\fs26 QUERYS\

\f1\b0\fs24 \

\f0\b query tables
\f1\b0 \
=> SELECT *  from <table_name>			get all rows from <table_name>\
=> SELECT <column_name>, <column_name> from <table_name>\
=> SELECT *  from <table_name>\
	WHERE <column_name> = value AND <column_name> = value\
	ORDER BY <column_name> DESC, <column_name>	ASC is default for ascencing\
\
	LIMIT 10;							only give 10 rows as outputlik\
\

\f0\b distinct
\f1\b0 \
=> SELECT DISTINCT <column> FROM <table>;		get only the unique values\
here DISTINCT has to follow directly after SELECT\
\

\f0\b distinct on
\f1\b0 \
=> SELECT <column>, DISTINCT ON <column_name> from <table_name>\
	\'85 ORDER BY <column_name>				get only unique (first) rows that have been ordered by that same expression (is like a GROUP BY)\
	\
\
=> SELECT <column_name> from <table1>, <table2>\
	WHERE <table1>.<column1> = <table2>.<column2>\
	WHERE <column1> LIKE 'S%'					LIKE restricts by pattern matching\
							%		stands for any number of characters\
							_		stands for one character\\\
\
=> SELECT <table1>.<column_name>, <table2>.<column_name>	inner join of two tables\
	FROM <table1> INNER JOIN <table2>				other joins: LEFT | RIGHT OUTER JOIN\
	ON (<table1>.<column1> = <table2>.<column2>)\
	\
if the joined column is named the same in both tables, you can use:\
	.. INNER JOIN <table2> USING (<same_column>)\
\
=> SELECT t1.<column1> AS c1, t2.<column2> AS c2		you can relable columns and tables like this\
	FROM <column1> c1, <column2> c2\
\
=> DROP TABLE <table_name>		delete an entire table\
\
\

\f0\b built-in functions\

\f1\b0 	random()				returns 0 <= value <= 1\
	abs(x)				absolute value\
	 mod(y, x) 				y % x\
\

\f0\b \
aggregate functions:\

\f1\b0 aggregate functions allow calculations across rows of the table\
\

\f0\b max()/min()/avg()
\f1\b0 \
=> SELECT max(<column1>) FROM <table1>				gets the maximum/min/average of all values\
\

\f0\b count()
\f1\b0 \
=> SELECT count(*) from <table>						number of rows from table\
! aggregate functions cannot be used in a WHERE clause -> here you can use a subquery in the WHERE clause:\
=> SELECT <column1> FROM <table1>\
	WHERE <column2> = (SELECT max(<column1>) FROM <table1>)\
the WHERE clause determines which rows go into the aggregate function\
\
\
\

\f0\b group by
\f1\b0 \
GROUP BY allows aggregate functions to be computed over all rows having the same value in a column\
=> SELECT <column1> , min(<column2>)\
	FROM <table1>\
	GROUP BY <column1>					aggregates are computed per column1 value\
\
in a GROUP BY you can afterwards filter the groups by a HAVING clause\
=> SELECT <column1> , min(<column2>)\
	FROM <table1>\
	GROUP BY <column1>					aggregates are computed per column1 value\
	HAVING max(<column3>) < value			optionally you can add filters on the rows partaking in the GROUP BY\
\
HAVING filters groups after any aggregates and can therefore contain aggregate functions\
\
the result of a GROUP BY is only the column you group by and any results of aggregate functions\
UNLESS!!!  if you group by a primary key of a table, all columns of that table will be available in the SELECT\
the aggregate functions can use all columns defined in the FROM \'85. JOIN -section\
\
\

\f0\b window functions:
\f1\b0 \
\
window functions allow aggregates to be taken on a window of rows related to the current row\
window functions require an OVER() containing the window to use\
\
SELECT <col1>, SUM(col1) OVER() FROM\'85			will sum up all col1 values of the result table\
SELECT <col1>, RANK() OVER(ORDER BY COUNT(<col>) DESC)  will rank after ordering the result table\
\
windows can be partitioned in the OVER statement (almost like a group by) \
SELECT <col1>, RANK() OVER(PARTITION BY <col_to_group_by> ORDER BY COUNT(<col>) ASC)\
\
a window can also be defined in a query to be reused\
\
SELECT <col1>, RANK() OVER w1 FROM \'85.\
WINDOW w1 AS (PARTITION BY <\'85.				the window is defined afterwards but used by the rank function\
\
\
\

\f0\b nested queries:
\f1\b0 \
you can use the resulting rows of SELECTS (inner query) as input for an outer query:\
\
examples would be contrived here \'97> only conceptual guide:\
 	the inner WHERE has access to the outer tables\
\

\f0\b CTE
\f1\b0  (as substitute for nested queries)\
you can label the inner query using WITH keyword and use as a Common Table Expression (CTE):\
	\
	WITH inner_query AS (SELECT \'85.)\
	SELECT * FROM <table> WHERE polls.id = (SELECT * FROM inner_query);\
\

\f0\b Views:\

\f1\b0 you can turn queries into views that allow the treatment of this query like a table:\
=> CREATE VIEW <view_name> AS				the view <view_name> is created\
	SELECT *  from <table_name>\
		WHERE <column_name> = value AND <column_name> = value\
		ORDER BY <column_name>, <column_name> \
=> SELECT * from <view_name>				now you can access view just like table\
the view is always computed at execution time UNLESS\
you create a materialized view:\
CREATE MATERIALIZED VIEW <view_name> AS SELECT\'85\'85\
a materialized view remains unchanged (and out of date) until you refresh it:\
REFRESH MATERIALIZED VIEW <view_name>;\
\
you can INSERT into simple views (SELECT\'85FROM\'85WHERE\'85)\
if you insert data that violates the where-clause, the data is simply stored in the underlying table UNLESS\
you specify WITH LOCAL CHECK OPTION at the end\
with WITH CASCADED CHECK OPTION   all nested views of upper levels are used with local check option\
\
\

\f0\b\fs28 User-defined functions\

\f1\b0\fs24 \

\f0\b create
\f1\b0 \
you can create user-defined functions for repeated uses:\
\
CREATE [OR REPLACE] FUNCTION <func>(<arg> <TYPE> DEFAULT <default_value>) RETURNS void AS $$  			\
	<code body>				return void if there is no return value/ TYPE can be [NUMERIC, TEXT, BIGINT, BOOLEAN, INTEGER]\
	expression with <arg>						\
$$ LANGUAGE SQL;			functions return the last evaluated statement\
\
you can also keep the arguments anonymous and refer to them positionally (bash-style) as $1, $2\'85\
run functions with:\
SELECT <func>(<arg>);\
\

\f0\b delete
\f1\b0  functions with:\
	DROP FUNCTION <func>(<TYPE>)							for deleting you have to give the argument type as well\
\

\f0\b composite types
\f1\b0 \
use composite types (like tables) as arguments or return values by referring to the table name as type\
CREATE FUNCTION <func>(table<table> ) RETURNS <table> AS $$	this functions uses tables both as argument and as return value\
	SELECT * FROM table;\
$$ LANGUAGE SQL;\
\
run composites using tables as argument as follows:\
SELECT <func>(<table>.*) FROM <table>;   or 	SELECT <func>(<table>)  $$		the function will receive individual rows of <table> as arguments\
	do something with <table>.column1								individual values of rows are used via their column name\
$$ LANGUAGE SQL;\
\
run composite functions returning tables as follows:\
SELECT * FROM <func>()\
\

\f0\b\fs28 Transactions (transaction blocks):
\f1\b0\fs24 \
in order to make sure, a group of actions is performed together as an atomic update (OR NOT), commands are marked as part of one transaction by being placed within a BEGIN; COMMIT; block\
=> BEGIN;					everything before the commit is perfomed atomically\
 	UPDATE \'85\'85\'85. ;\
 	UPDATE \'85\'85\'85. ;\
	DELETE \'85\'85\'85. ;\
	INSERT \'85\'85\'85.. ;\
 COMMIT;\
	\
=> BEGIN;\
	\'85\'85..\
	ROLLBACK;				a rollback statement withdraws any changes after the begin statement\
\
=> BEGIN;\
	\'85\'85..\
	SAVEPOINT <point>;\
	\'85\'85..\
	ROLLBACK TO <point>;				a rollback statement withdraws any changes after the begin statement\
\
\

\f0\b\fs28 Procedures (stored transactions)
\f1\b0\fs24 \
stored procedures are best written in plpgsql because it does not (among other improvements) validate the stored transaction prior to running it\
\
create\
CREATE PROCEDURE <my_proc>() AS $$\
BEGIN							plpgsql does not want a semicolon after BEGIN\
	do stuff\
	INSERT INTO <table> VALUES (value1, value2);			here you can run actual transactions\
	do stuff\
	COMMIT;\
END;						\
\
execute\
CALL <my_proc>()\
\

\f0\b SQL data types:\

\f1\b0 	char(N)\
	varchar(N)				string of max length 80\
	int\
	smallint\
	real\
	double precision\
	date\
	time\
	timestamp / interval\
postgreSQL-specific data types:\
	point					an n-tuple  ( N1, N2, N3)\
	text					variable length character string\
various other user-defined data types can be created\
\
\
\

\f0\b Table Control:
\f1\b0 \
DELETE FROM table			deletes all rows from a table\
DROP SCHEMA public CASCADE;	removes all tables from db\
CREATE SCHEMA public;			 ..and recreates an empty public schema\
\
\
}